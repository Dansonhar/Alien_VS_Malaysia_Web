<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Alien Copycat - Aliens vs Malaysians</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { 'fredoka': ['Fredoka', 'sans-serif'] },
                    colors: { 'sambal': '#FF5252', 'durian': '#FFD600', 'pandan': '#00E676' }
                }
            }
        }
    </script>
</head>

<body class="font-fredoka bg-gray-900 min-h-screen overflow-hidden touch-none select-none">

    <!-- HUD -->
    <div id="hud" class="hidden fixed top-4 left-1/2 -translate-x-1/2 z-50 flex gap-4 pointer-events-none">
        <div class="bg-white/90 px-4 py-2 rounded-full border-4 border-black shadow-[4px_4px_0_#000] font-bold text-lg">
            SCORE: <span id="score" class="text-pandan">0</span>
        </div>
        <div class="bg-white/90 px-4 py-2 rounded-full border-4 border-black shadow-[4px_4px_0_#000] font-bold text-lg">
            TIME: <span id="timer" class="text-sambal">30</span>s
        </div>
        <div id="comboContainer"
            class="hidden bg-orange-500/90 text-white px-4 py-2 rounded-full border-4 border-black shadow-[4px_4px_0_#000] font-bold text-lg animate-pulse">
            üî• COMBO: <span id="combo">0</span>
        </div>
    </div>

    <canvas id="gameCanvas" class="block w-full h-screen"></canvas>

    <!-- Start Screen -->
    <div id="startScreen"
        class="fixed inset-0 bg-black/85 flex flex-col items-center justify-center z-[100] text-center px-4">
        <h1 class="text-5xl md:text-6xl font-bold text-purple-400 drop-shadow-[0_4px_0_#000] mb-4">
            üëΩ ALIEN COPYCAT
        </h1>
        <div class="text-6xl mb-6 animate-bounce">üëæ ‚ùì üëæ</div>
        <p class="text-white text-xl mb-8">One alien is acting sus!<br>Find the one that's different!</p>
        <button onclick="startGame()"
            class="bg-purple-600 text-white font-bold text-2xl px-12 py-4 rounded-full border-4 border-white shadow-[0_8px_0_#6A1B9A] hover:-translate-y-1 active:translate-y-1 active:shadow-[0_4px_0_#6A1B9A] transition-all">
            SPOT THE FAKE
        </button>
    </div>

    <!-- End Screen -->
    <div id="endScreen"
        class="hidden fixed inset-0 bg-black/85 flex flex-col items-center justify-center z-[100] text-center px-4">
        <h1 class="text-5xl md:text-6xl font-bold text-sambal drop-shadow-[0_4px_0_#000] mb-4">
            GAME OVER
        </h1>
        <p class="text-white text-2xl mb-4">Imposters Found:</p>
        <div id="finalScore" class="text-7xl font-bold text-pandan drop-shadow-[0_4px_0_#000] mb-8">0</div>
        <button onclick="startGame()"
            class="bg-pandan text-white font-bold text-2xl px-12 py-4 rounded-full border-4 border-black shadow-[0_8px_0_#2E7D32] hover:-translate-y-1 active:translate-y-1 active:shadow-[0_4px_0_#2E7D32] transition-all">
            PLAY AGAIN
        </button>
        <button onclick="window.location.href='../'"
            class="mt-4 bg-gray-600 text-white font-bold px-6 py-2 rounded-full border-2 border-black">
            BACK TO MENU
        </button>
    </div>

    <button onclick="window.location.href='../'"
        class="fixed bottom-4 left-4 z-[200] bg-red-500 hover:bg-red-600 text-white font-bold px-6 py-3 rounded-xl border-4 border-black shadow-[4px_4px_0_#000] hover:shadow-[2px_2px_0_#000] hover:translate-y-[2px] transition-all flex items-center gap-2">
        <span class="text-2xl">üè†</span> BACK TO MENU
    </button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            calculateLayout();
        }
        window.addEventListener('resize', resize);

        // Game State
        let gameRunning = false;
        let score = 0;
        let timeLeft = 30;
        let combo = 0;
        let timerInterval = null;
        let gridCols = 2;
        let aliens = [];
        let particles = [];
        let shake = 0;
        let correctIndex = -1;
        let frameCount = 0;

        // Layout
        let cellSize = 0;
        let gridStartX = 0;
        let gridStartY = 0;

        // Colors
        const alienColors = [
            { body: '#76FF03', dark: '#33691E' }, // Green
            { body: '#2979FF', dark: '#0D47A1' }, // Blue
            { body: '#FF4081', dark: '#880E4F' }, // Pink
            { body: '#FFD740', dark: '#FF6F00' }, // Yellow
            { body: '#E040FB', dark: '#AA00FF' }  // Purple
        ];

        class Alien {
            constructor(row, col, isImposter, difficulty) {
                this.row = row;
                this.col = col;
                this.isImposter = isImposter;
                this.difficulty = difficulty;

                // Base properties
                this.color = alienColors[Math.floor(Math.random() * alienColors.length)];
                this.eyeSize = 1;
                this.mouthSize = 1;
                this.antenna = true;
                this.hueOffset = 0;

                // Animation offsets
                this.breathOffset = Math.random() * 100;
                this.blinkTimer = Math.random() * 200;
                this.lookOffset = Math.random() * 100;

                // Apply Imposter Differences
                if (isImposter) {
                    this.applyDifference();
                }

                // Spawn Animation
                this.scale = 0;
                this.targetScale = 1;
            }

            applyDifference() {
                // Difficulty 0-10 determines subtlety
                const diffType = Math.floor(Math.random() * 3);

                if (this.difficulty < 3) {
                    // Easier: Color Change
                    this.hueOffset = 40 + Math.random() * 50;
                } else if (this.difficulty < 6) {
                    // Medium: Eye Size or Missing Antenna
                    if (Math.random() < 0.5) this.eyeSize = 0.6;
                    else this.antenna = false;
                } else {
                    // Hard: Subtle Color or Breathing Speed (implied by just slight visual diffs)
                    // Let's stick to visual diffs
                    this.hueOffset = 20;
                }
            }

            update() {
                // Spawn/Pop in
                if (this.scale < this.targetScale) {
                    this.scale += (this.targetScale - this.scale) * 0.2;
                }

                this.blinkTimer--;
                if (this.blinkTimer < -10) this.blinkTimer = 100 + Math.random() * 200;
            }

            draw(x, y, size) {
                ctx.save();
                ctx.translate(x + size / 2, y + size / 2);
                ctx.scale(this.scale, this.scale);

                // Breathing
                const breath = Math.sin((frameCount + this.breathOffset) * 0.05) * 0.05;
                ctx.scale(1 + breath, 1 - breath);

                // Filter for color change if imposter (hue shift)
                if (this.hueOffset !== 0) {
                    ctx.filter = `hue-rotate(${this.hueOffset}deg)`;
                }

                const s = size * 0.8; // Alien size relative to cell

                // Antenna
                if (this.antenna) {
                    ctx.beginPath();
                    ctx.moveTo(0, -s * 0.3);
                    ctx.lineTo(0, -s * 0.5);
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = this.color.dark;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, -s * 0.5, s * 0.05, 0, Math.PI * 2);
                    ctx.fillStyle = this.color.dark;
                    ctx.fill();
                }

                // Body
                ctx.fillStyle = this.color.body;
                ctx.beginPath();
                ctx.arc(0, 0, s * 0.35, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                const blink = this.blinkTimer < 0 ? 0.1 : 1;
                const eyeS = s * 0.12 * this.eyeSize;

                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.ellipse(-s * 0.12, -s * 0.05, eyeS, eyeS * blink, 0, 0, Math.PI * 2);
                ctx.ellipse(s * 0.12, -s * 0.05, eyeS, eyeS * blink, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (Look around)
                const lookX = Math.sin((frameCount + this.lookOffset) * 0.02) * (eyeS * 0.3);
                const lookY = Math.cos((frameCount + this.lookOffset) * 0.03) * (eyeS * 0.3);

                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(-s * 0.12 + lookX, -s * 0.05 + lookY, eyeS * 0.4, eyeS * 0.4 * blink, 0, 0, Math.PI * 2);
                ctx.ellipse(s * 0.12 + lookX, -s * 0.05 + lookY, eyeS * 0.4, eyeS * 0.4 * blink, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.beginPath();
                ctx.arc(0, s * 0.15, s * 0.08 * this.mouthSize, 0, Math.PI);
                ctx.strokeStyle = this.color.dark;
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 15;
                this.vy = (Math.random() - 0.5) * 15;
                this.life = 1;
                this.color = color;
                this.size = Math.random() * 8 + 4;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= 0.03;
                this.vy += 0.5; // Gravity
                this.size *= 0.95;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function calculateLayout() {
            // Leave space for HUD
            const availWidth = width * 0.9;
            const availHeight = height * 0.8;

            // Grid calculations
            cellSize = Math.min(availWidth / gridCols, availHeight / gridCols);
            gridStartX = (width - (cellSize * gridCols)) / 2;
            gridStartY = (height - (cellSize * gridCols)) / 2 + 40;
        }

        function nextRound() {
            // Difficulty Scaling
            if (score > 30) gridCols = 5;
            else if (score > 15) gridCols = 4;
            else if (score > 5) gridCols = 3;
            else gridCols = 2;

            calculateLayout();

            aliens = [];
            const total = gridCols * gridCols;
            correctIndex = Math.floor(Math.random() * total);

            // Pick a common base color for this round to make spotting diff harder
            // Or keep it random per round?
            // Actually, for "Find the imposter", typically "Find the different ONE", implies others are SAME.
            // So we must generate ONE base alien, and ONE imposter.

            const baseAlienProps = {
                // Just use random seed properties, Alien class logic is per instance.
                // We need to synchronize the "base" look.
                color: alienColors[Math.floor(Math.random() * alienColors.length)],
                eyeSize: 1,
                antenna: true
            };

            for (let i = 0; i < total; i++) {
                const r = Math.floor(i / gridCols);
                const c = i % gridCols;

                const isImposter = (i === correctIndex);
                const newAlien = new Alien(r, c, isImposter, Math.min(10, Math.floor(score / 5)));

                // Enforce sameness for non-imposters
                if (!isImposter) {
                    newAlien.hueOffset = 0;
                    newAlien.color = baseAlienProps.color;
                    newAlien.eyeSize = 1;
                    newAlien.antenna = true;
                } else {
                    // Imposter needs to start from base and deviate
                    newAlien.color = baseAlienProps.color;
                    newAlien.eyeSize = 1;
                    newAlien.antenna = true;
                    newAlien.applyDifference(); // Apply deviation
                }

                aliens.push(newAlien);
            }
        }

        function spawnParticles(x, y, color) {
            for (let i = 0; i < 20; i++) particles.push(new Particle(x, y, color));
        }

        function handleInput(e) {
            if (!gameRunning) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            const x = cx - rect.left;
            const y = cy - rect.top;

            // Check grid click
            const col = Math.floor((x - gridStartX) / cellSize);
            const row = Math.floor((y - gridStartY) / cellSize);

            if (col >= 0 && col < gridCols && row >= 0 && row < gridCols) {
                const index = row * gridCols + col;
                if (index < aliens.length) {
                    // Clicked an alien
                    if (aliens[index].isImposter) {
                        // Correct!
                        score++;
                        combo++;
                        timeLeft = Math.min(30, timeLeft + 2); // Time bonus
                        shake = 10;
                        spawnParticles(x, y, '#76FF03'); // Green splash

                        // Combo feedback
                        if (combo > 2) {
                            document.getElementById('comboContainer').classList.remove('hidden');
                            document.getElementById('combo').textContent = combo;
                        }

                        updateHUD();
                        // Small delay before next round to see particles? Or instant?
                        // Instant is more exciting for "Time Attack" feel
                        nextRound();
                    } else {
                        // Wrong!
                        timeLeft -= 5;
                        combo = 0;
                        shake = 20;
                        spawnParticles(x, y, '#FF5252'); // Red splash
                        document.getElementById('comboContainer').classList.add('hidden');
                        updateHUD();
                        if (timeLeft <= 0) endGame();
                    }
                }
            }
        }

        function loop() {
            if (!gameRunning) return;

            // Shake Effect
            let shakeX = 0, shakeY = 0;
            if (shake > 0) {
                shakeX = (Math.random() - 0.5) * shake;
                shakeY = (Math.random() - 0.5) * shake;
                shake *= 0.9;
                if (shake < 0.5) shake = 0;
            }

            ctx.save();
            ctx.translate(shakeX, shakeY);
            ctx.clearRect(0, 0, width, height);

            frameCount++;

            // Draw Aliens (Grid)
            aliens.forEach(a => {
                a.update();
                const x = gridStartX + a.col * cellSize;
                const y = gridStartY + a.row * cellSize;
                a.draw(x, y, cellSize);
            });

            // Draw Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }

            ctx.restore();
            requestAnimationFrame(loop);
        }

        function startGame() {
            score = 0;
            timeLeft = 30;
            combo = 0;
            gridCols = 2;
            particles = [];
            gameRunning = true;
            resize(); // Force layout update

            document.getElementById('score').textContent = score;
            document.getElementById('timer').textContent = timeLeft;
            document.getElementById('comboContainer').classList.add('hidden');

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('endScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');

            nextRound();

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('timer').textContent = timeLeft;
                if (timeLeft <= 0) endGame();
            }, 1000);

            requestAnimationFrame(loop);
        }

        function endGame() {
            gameRunning = false;
            clearInterval(timerInterval);
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('finalScore').textContent = score;
            document.getElementById('endScreen').classList.remove('hidden');
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('timer').textContent = timeLeft;
        }

        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput);

        // Initial Draw
        resize();

    </script>
</body>

</html>