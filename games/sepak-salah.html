<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sepak Salah - Aliens vs Malaysians</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .game-text {
            text-shadow: 2px 2px 0px #000;
        }

        /* Pulse Animation for HUD */
        @keyframes pulse-red {
            0% {
                transform: scale(1);
                color: #FBBF24;
            }

            50% {
                transform: scale(1.1);
                color: #EF4444;
            }

            100% {
                transform: scale(1);
                color: #FBBF24;
            }
        }

        .pulse-active {
            animation: pulse-red 0.5s infinite;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body class="bg-black text-white w-full h-screen relative">

    <!-- CANVAS LAYER -->
    <canvas id="gameCanvas" class="absolute top-0 left-0 w-full h-full z-0"></canvas>

    <!-- UI LAYER -->
    <div id="uiLayer"
        class="absolute top-0 left-0 w-full h-full z-10 pointer-events-none flex flex-col justify-between p-6">

        <!-- HUD -->
        <div id="hud" class="hidden flex justify-between items-start w-full">
            <button onclick="window.location.href='../'"
                class="pointer-events-auto bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-full border-4 border-white shadow-lg text-lg">
                üè† MENU
            </button>

            <div class="flex flex-col items-center">
                <div class="bg-gray-900/80 rounded-full px-8 py-2 border-4 border-white mb-2">
                    <span id="timerDisplay" class="text-5xl font-bold text-yellow-400 game-text">60</span>
                </div>
            </div>

            <div class="bg-blue-600 rounded-lg px-6 py-2 border-4 border-white flex flex-col items-end">
                <span class="text-sm font-bold uppercase">Score</span>
                <span id="scoreDisplay" class="text-4xl font-bold game-text">0</span>
            </div>
        </div>

        <!-- CENTER MESSAGES -->
        <div id="centerMessage" class="absolute inset-0 flex items-center justify-center pointer-events-none"></div>

    </div>

    <!-- MENUS -->
    <div id="menuOverlay" class="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">

        <!-- MAIN MENU -->
        <div id="mainMenu"
            class="text-center w-full max-w-2xl p-8 bg-white/10 rounded-3xl border-8 border-yellow-400 shadow-[0_0_50px_rgba(255,215,0,0.5)]">
            <h1 class="text-7xl font-black text-yellow-400 mb-2 game-text italic">SEPAK SALAH!</h1>
            <p class="text-2xl text-white mb-8 font-bold">"Kick the ball, not the Malaysian!"</p>

            <div class="flex justify-center gap-4 mb-8">
                <button onclick="startGame()"
                    class="pointer-events-auto bg-green-500 hover:bg-green-600 text-white text-4xl font-bold py-6 px-12 rounded-full border-b-8 border-green-800 active:border-b-0 active:translate-y-2 transition-all">
                    START GAME ‚öΩ
                </button>
            </div>
            <button onclick="window.location.href='../'"
                class="pointer-events-auto text-gray-400 hover:text-white underline">Back to Hub</button>
        </div>

        <!-- GAME OVER -->
        <div id="resultScreen" class="hidden text-center w-full max-w-2xl">
            <h2 class="text-6xl font-black text-white mb-4 game-text">GAME OVER</h2>
            <div class="mb-8">
                <p class="text-2xl text-yellow-300">FINAL SCORE</p>
                <p id="finalScore" class="text-6xl font-bold">0</p>
            </div>
            <div class="flex justify-center gap-4">
                <button onclick="location.reload()"
                    class="pointer-events-auto bg-blue-500 hover:bg-blue-600 text-white text-2xl font-bold py-4 px-8 rounded-full border-b-6 border-blue-800 active:border-b-0 active:translate-y-2">
                    REMATCH üîÑ
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ASSETS
        const ASSETS = {
            stadium: new Image(),
            goal: new Image(),
            alien: new Image(),
            malaysian: new Image()
        };
        ASSETS.stadium.src = '../assets/stadium_bg.png';
        ASSETS.goal.src = '../assets/goal_v3.png';
        ASSETS.alien.src = '../assets/alien_purple_v2.png';
        ASSETS.malaysian.src = '../assets/malaysian_male.png';

        // Helper: Transparent Image Processor
        // Helper: Transparent Image Processor
        // Removed: Performed offline to avoid CORS/SecurityError on file:// protocol


        // --- GAME STATE ---
        let width, height;
        let gameState = 'MENU'; // MENU, PLAYING, RESULT
        let score = 0;
        let timeLeft = 60;
        let particles = [];
        let popups = [];

        // Asset Loading Wrapper
        let resourcesLoaded = 0;
        function checkLoad() {
            resourcesLoaded++;
            if (resourcesLoaded === 4) {
                render();
                resize();
            }
        }

        ASSETS.stadium.onload = checkLoad;
        ASSETS.goal.onload = checkLoad;
        ASSETS.alien.onload = checkLoad;
        ASSETS.malaysian.onload = checkLoad;

        // Physics Objects
        let ball = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, state: 'idle' }; // idle, moving, scored, missed
        let keeper = { x: 0, targetX: 0, speed: 0.05, width: 100, type: 'alien' }; // Slower speed logic in update
        let goalDim = { x: 0, y: 0, w: 0, h: 0, depth: 400 };

        // Helper
        const perspective = 800;
        function project(x, y, z) {
            const scale = perspective / (perspective + z);
            return {
                x: width / 2 + x * scale,
                y: height / 2 + y * scale,
                scale: scale
            };
        }

        // --- RESIZE ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;

            // Setup Goal Dimensions (Visual)
            // Goal image is roughly square based on user info (847x843). 
            // We want it rectangular in perspective.
            // Let's force a 1.5 aspect ratio for gameplay.
            const goalScale = Math.min(width * 0.8, height * 0.5);
            goalDim.w = goalScale;
            goalDim.h = goalScale * 0.6;
            goalDim.y = height * 0.2; // Offset from center
        }
        window.addEventListener('resize', resize);
        resize();

        // --- INPUT ---
        // --- INPUT (STRICT FORWARD 180) ---
        function handleInput(clientX, clientY) {
            if (gameState !== 'PLAYING' || ball.state !== 'idle') return;

            // Project ball to screen space to get origin
            const pBall = project(ball.x, ball.y, ball.z);

            // Calculate Vector: Ball -> Click
            // Note: Screen Y is inverted relative to "Forward". Up is negative Y.
            const dx = clientX - pBall.x;
            const dy = clientY - pBall.y;

            // MATH FOR ANGLE CLAMPING
            // We want 0 degrees to be "Straight Forward" (Up on screen, -Y).
            // atan2(y, x) gives angle relative to positive X axis (Right).
            // Right = 0, Down = 90, Left = 180, Up = -90.

            let angle = Math.atan2(dy, dx);
            let degrees = angle * (180 / Math.PI);

            // Map Standard Angle to "Forward = 0" Reference
            // Standard Up (-90) -> should be 0.
            // So: Mapped = Standard + 90.
            // Up: -90 + 90 = 0.
            // Right: 0 + 90 = 90.
            // Left: 180 + 90 = 270 (or -90 if wrapped).

            let forwardAngle = degrees + 90;

            // Normalize to -180 to 180
            if (forwardAngle > 180) forwardAngle -= 360;
            if (forwardAngle < -180) forwardAngle += 360;

            // CLAMPING Logic (-90 to +90)
            if (forwardAngle > 90) forwardAngle = 90;   // Clamp Right
            if (forwardAngle < -90) forwardAngle = -90; // Clamp Left

            // Convert back to standard radians for component calculation (relative to 0=Right)
            // Standard = Mapped - 90
            const finalRad = (forwardAngle - 90) * (Math.PI / 180);

            // Physics
            const speed = 28; // Fast

            // cos(angle) = X component. sin(angle) = Y component (Screen Y).
            // Screen Y maps to World Z (Forward/Backward). 
            // Negative Screen Y is Forward (Positive Z in game logic? Let's check).
            // Previous code: vy = -12 (Up/Arc). vz = 25 (Forward).
            // If we kick Straight Up (Screen -Y), we want Max Positive Z.

            // Let's use the components from the angle directly
            // vx -> Screen X
            // vz -> Screen -Y (Forward into screen)

            const screenVx = Math.cos(finalRad) * speed;
            const screenVy = Math.sin(finalRad) * speed; // This is Y on screen

            ball.vx = screenVx * 0.5; // X velocity
            ball.vz = -screenVy;      // Z velocity (Invert Screen Y to get World Z Forward)

            // Ensure Z is always positive (Forward) just to be safe, though clamping handles it.
            if (ball.vz < 0) ball.vz = 0;

            ball.vy = -6; // Flatter arc for "Straight Line" feel
            ball.state = 'moving';

            spawnParticles(pBall.x, pBall.y, 10, '#FFF', 2);
        }

        // Global Event Listener (Interactive Wall)
        canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        });

        // --- PARTICLES ---
        class Particle {
            constructor(x, y, color, speedScale = 1) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10 * speedScale;
                this.vy = (Math.random() - 1) * 10 * speedScale;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 5 + 2;
                this.gravity = 0.5;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.life -= 0.03;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        function spawnParticles(x, y, count, color, speed) {
            for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color, speed));
        }

        function spawnPopup(text, color) {
            popups.push({ text, color, life: 1.0, y: height / 2 });
        }

        // --- LOGIC ---
        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            timeLeft = 60;
            document.getElementById('menuOverlay').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('scoreDisplay').textContent = "0";
            resetBall();
            spawnPopup("TAP BALL TO KICK!", "#FFF");
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function resetBall() {
            ball = { x: 0, y: 150, z: -350, vx: 0, vy: 0, vz: 0, state: 'idle' };
            // Ball position relative to center: 
            // x=0 is center. y positive is down. z negative is close to camera.
            // Goal is at z=goalDepth (positive).
        }

        function update(dt) {
            // Timer
            if (gameState === 'PLAYING') {
                timeLeft -= dt;
                document.getElementById('timerDisplay').textContent = Math.ceil(timeLeft);
                if (timeLeft <= 10) document.getElementById('timerDisplay').classList.add('pulse-active');
                if (timeLeft <= 0) endGame();
            }

            // Goalkeeper AI (Basic)
            // Goal Width Boundaries
            const limit = 400; // range
            // Start Keeper in Middle
            // keeper.x += (keeper.targetX - keeper.x) * 0.05; 
            // Better logic: Keeper waits in middle, then reacts? 
            // For now, keep random movement but centered bias

            if (Math.abs(keeper.x - keeper.targetX) < 10) {
                // 50% chance to move to center (0), 50% chance to move random
                if (Math.random() > 0.5) keeper.targetX = 0;
                else keeper.targetX = (Math.random() - 0.5) * limit;
            }
            keeper.x += (keeper.targetX - keeper.x) * 0.05;

            if (Math.abs(keeper.x - keeper.targetX) < 10) {
                keeper.targetX = (Math.random() - 0.5) * limit; // Pick new spot
            }

            // Ball Physics
            if (ball.state === 'moving') {
                ball.x += ball.vx;
                ball.y += ball.vy;
                ball.z += ball.vz;
                ball.vy += 0.5; // Gravity

                // Ground Bounce
                if (ball.y > 200) { // arbitrary floor plane
                    ball.y = 200;
                    ball.vy *= -0.6;
                    ball.vx *= 0.9;
                }

                // Goal Check
                if (ball.z > 300 && ball.z < 350) { // Passing goal line
                    // Dimensions check
                    // Goal is roughly -250 to 250 in X, -200 to 200 in Y (relative)
                    if (Math.abs(ball.x) < 250 && ball.y < 200 && ball.y > -200) {

                        // Keeper Collision
                        // Simple 2D box check at the goal plane
                        if (Math.abs(ball.x - keeper.x) < 80) { // Hit Keeper!
                            ball.vx *= -1;
                            ball.vz *= -0.5;
                            ball.state = 'missed';
                            spawnParticles(width / 2 + ball.x, height / 2 + ball.y, 20, '#F00', 3);
                            spawnPopup("BLOCKED!", "#EF4444");
                            setTimeout(resetBall, 1000);
                        } else {
                            // GOAL!
                            score += 100;
                            document.getElementById('scoreDisplay').textContent = score;
                            ball.state = 'scored';
                            spawnParticles(width / 2 + ball.x, height / 2 + ball.y, 30, '#FFD700', 4);
                            spawnPopup("GOAL!!!", "#FBBF24");
                            setTimeout(resetBall, 1000);
                        }
                    } else if (ball.z > 400) {
                        // Missed completely
                        ball.state = 'missed';
                        spawnPopup("MISS!", "#FFF");
                        setTimeout(resetBall, 1000);
                    }
                }

                // Far out bounds
                if (ball.z > 600) {
                    ball.state = 'missed';
                    setTimeout(resetBall, 500);
                }
            }

            // Particles
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
            popups.forEach(p => { p.life -= 0.02; p.y -= 1; });
            popups = popups.filter(p => p.life > 0);
        }

        function render() {
            ctx.clearRect(0, 0, width, height);

            // 1. STADIUM BACKGROUND
            if (ASSETS.stadium.complete) {
                ctx.drawImage(ASSETS.stadium, 0, 0, width, height);
            } else {
                ctx.fillStyle = '#111'; ctx.fillRect(0, 0, width, height);
            }

            // 2. FIELD GRADIENT (Floor)
            const horizonY = height * 0.45;
            const grad = ctx.createLinearGradient(0, horizonY, 0, height);
            grad.addColorStop(0, '#0f2e0f'); // Dark Green Distant
            grad.addColorStop(0.4, '#1a4a1a');
            grad.addColorStop(1, '#2e7d32'); // Lighter Green Close
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, horizonY);
            ctx.lineTo(width, horizonY);
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.fill();

            // Grid Lines for perspective
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = -500; i <= 500; i += 100) {
                let p1 = project(i, 200, 0); // floor plane
                let p2 = project(i * 5, 200, 1000);
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();

            // 3. GOAL
            // Draw goal at Z = 350
            const goalZ = 350;
            const pGoal = project(0, 200, goalZ); // Base of goal
            if (ASSETS.goal.complete) {
                const gw = 600 * pGoal.scale;
                const gh = 600 * pGoal.scale * 0.7; // Aspect ratio fix (~1.4)
                // Adjust to center bottom
                ctx.drawImage(ASSETS.goal, pGoal.x - gw / 2, pGoal.y - gh, gw, gh);
            }

            // 4. KEEPER (Alien)
            const pKeeper = project(keeper.x, 200, goalZ - 20); // Slightly in front
            if (ASSETS.alien.complete) {
                const kw = 120 * pKeeper.scale;
                const kh = 180 * pKeeper.scale; // Tall alien

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(pKeeper.x, pKeeper.y, kw / 2, kw / 5, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.drawImage(ASSETS.alien, pKeeper.x - kw / 2, pKeeper.y - kh, kw, kh);
            }

            // 5. BALL
            const pBall = project(ball.x, ball.y, ball.z);
            const size = 30 * pBall.scale;

            // Ball Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            // Project shadow on ground (y=200)
            const pShadow = project(ball.x, 200, ball.z);
            const sSize = 30 * pShadow.scale;
            ctx.ellipse(pShadow.x, pShadow.y, sSize, sSize / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw Ball (White circle with shading for now, simple)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(pBall.x, pBall.y, size, 0, Math.PI * 2);
            ctx.fill();
            // Shading detail
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.arc(pBall.x - size * 0.3, pBall.y - size * 0.3, size * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // 6. PARTICLES & POPUPS
            particles.forEach(p => p.draw(ctx));
            popups.forEach(p => {
                ctx.font = "900 60px Fredoka";
                ctx.fillStyle = p.color;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4;
                ctx.textAlign = 'center';
                ctx.globalAlpha = p.life;
                ctx.strokeText(p.text, width / 2, p.y);
                ctx.fillText(p.text, width / 2, p.y);
                ctx.globalAlpha = 1;
            });
        }

        function endGame() {
            gameState = 'RESULT';
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('resultScreen').classList.remove('hidden');
            document.getElementById('finalScore').textContent = score;
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState !== 'PLAYING') return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(dt);
            render();
            requestAnimationFrame(gameLoop);
        }

        // Initial Render
        // ASSETS.stadium.onload handled by checkLoad
    </script>
</body>

</html>